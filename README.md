2. Encapsulation
Encapsulation is the concept of restricting access to certain components of an object and only exposing necessary parts. It is achieved using access modifiers (public, private, protected, internal).

When to use: To protect the integrity of an object's data and hide the internal implementation details.

Why: Encapsulation increases security and reduces the impact of changes by providing a clear interface for interacting with objects.

____________________________________________________________________________

3. Inheritance
Inheritance allows one class (derived class) to inherit fields and methods from another class (base class).

When to use: When there are commonalities among classes that can be abstracted into a base class to avoid code duplication.

Why: Inheritance promotes code reuse and establishes a natural hierarchy among classes, making the code more organized and manageable.

____________________________________________________________________________

4. Polymorphism
Polymorphism allows objects of different classes to be treated as objects of a common base class. It is mainly achieved through method overriding and interface implementation.

When to use: When you need to perform the same action in different ways depending on the object type.

Why: Polymorphism enhances flexibility and scalability by allowing you to write more generic and reusable code.

____________________________________________________________________________

5. Abstraction
Abstraction is the concept of simplifying complex systems by modeling classes appropriate to the problem, focusing on essential characteristics rather than specific details.

When to use: When you need to define a class to represent a general concept without specifying implementation details.

______________________________________________________________________________

2. ინკაფსულაცია
კაფსულაცია არის ობიექტის გარკვეულ კომპონენტებზე წვდომის შეზღუდვის და მხოლოდ აუცილებელი ნაწილების გამოვლენის კონცეფცია. იგი მიიღწევა წვდომის მოდიფიკატორების გამოყენებით (საჯარო, კერძო, დაცული, შიდა).

როდის გამოვიყენოთ: ობიექტის მონაცემების მთლიანობის დასაცავად და შიდა განხორციელების დეტალების დამალვა.

რატომ: ინკაფსულაცია ზრდის უსაფრთხოებას და ამცირებს ცვლილებების გავლენას ობიექტებთან ურთიერთქმედებისთვის მკაფიო ინტერფეისის უზრუნველყოფით.

________________________________________________________________________________

3. მემკვიდრეობა
მემკვიდრეობა საშუალებას აძლევს ერთ კლასს (მიღებულ კლასს) მიიღოს ველები და მეთოდები სხვა კლასისგან (ბაზისური კლასი).

როდის გამოვიყენოთ: როდესაც არის კლასებს შორის საერთო, რომელიც შეიძლება აბსტრაქტირებული იყოს საბაზო კლასში, რათა თავიდან იქნას აცილებული კოდის დუბლირება.

რატომ: მემკვიდრეობა ხელს უწყობს კოდის ხელახლა გამოყენებას და ადგენს ბუნებრივ იერარქიას კლასებს შორის, რაც კოდს უფრო ორგანიზებულ და მართვადს ხდის.

________________________________________________________________

4. პოლიმორფიზმი
პოლიმორფიზმი საშუალებას აძლევს სხვადასხვა კლასის ობიექტებს განიხილონ როგორც საერთო საბაზისო კლასის ობიექტები. ის ძირითადად მიიღწევა მეთოდის გადაფარვისა და ინტერფეისის დანერგვით.

როდის გამოვიყენოთ: როდესაც ერთი და იგივე მოქმედების შესრულება გჭირდებათ სხვადასხვა გზით, ობიექტის ტიპის მიხედვით.

რატომ: პოლიმორფიზმი აძლიერებს მოქნილობას და მასშტაბურობას, რაც საშუალებას გაძლევთ დაწეროთ უფრო ზოგადი და მრავალჯერადი კოდი.

________________________________________________________________________________

5. აბსტრაქცია
აბსტრაქცია არის რთული სისტემების გამარტივების კონცეფცია პრობლემის შესაბამისი კლასების მოდელირებით, ფოკუსირებული არსებით მახასიათებლებზე და არა კონკრეტულ დეტალებზე.

როდის გამოვიყენოთ: როდესაც გჭირდებათ კლასის განსაზღვრა ზოგადი კონცეფციის წარმოსადგენად, განხორციელების დეტალების მითითების გარეშე.

